<!DOCTYPE html>
<html lang="en">
<!-- Hier beginnt der Administrative Teil der Seite -->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="ByronStar">

  <title>Programmiersprachen - Cheatsheet</title>

  <!-- Rainbow CSS and Javascript -->
  <link href="css/code.css" rel="stylesheet">
  <script type="text/javascript" src="lib/rainbow-custom.min.js"></script>

  <!-- Velocity -->
  <!--
    <script type="text/javascript" src="lib/velocity.min.js"></script>
    -->

  <!-- p5js -->
  <!--
    <script src="lib/p5.js" type="text/javascript"></script>
    <script src="lib/p5.dom.js" type="text/javascript"></script>
    <script src="lib/p5.sound.js" type="text/javascript"></script>
    -->

  <!-- matter.js -->
  <!--
    <script type="text/javascript" src="lib/matter.js"></script>
    -->

  <!-- Javascript Programm in separater Datei -->
  <!-- <script type="text/javascript" src="js/cheatsheet_bare.js"></script> -->

  <!-- Styles in separater Datei -->
  <link rel="stylesheet" href="css/cheatsheet.css">

  <!-- Inline Styles -->
  <style>
    .progsp g#layer0 rect {
      fill: #808080;
    }
  </style>
</head>

<!-- Hier beginnt der eigentliche Inhalt der Seite -->
<body class="progsp">
  <pre>
        <code data-language="javascript">
// Hier beginnt das Javascript 'Program' - die beiden // machen aus diesem Text einen 'Comment'
// der vom Browser ignoriert wird, aber dem Programmierer eventuell wichtige Hinweise gibt.
// Wenn ganz viele Zeilen als 'Comment' gelten sollen benutzt man /* und */ für Anfang und Ende.

/*
Jeder Text ausserhalb von jeglichen { und } Klammern ist 'Global' und wird vom Browser
sofort beim Lesen der Datei ausgeführt. Alles was 'Global' ist, kann überall im 'Program'
verwendet werden. Klammern, Gleichheitszeichen, Semicolon, ... haben immer spezielle
Bedeutung 'Operators', 'Special Characters', es sei denn sie sind Teil eines 'Strings' (siehe unten).
*/

// Wir starten mit den Daten - 'Variable' - eines 'Programs', erkennbar am Schlüsselwort 'Keyword'
// 'var' gefolgt von einem frei wählbaren Namen.
var hugo1;

// Eine 'Variable' kann (muss aber nicht) sofort mit einem Wert - 'Value' versehen werden:
var hugo2 = 0;

// Das war die erste Anweisung - 'Statement' - im 'Program'. Ein 'Statement' wird mit ';' beendet
// Das ist nicht mehr zwingend notwendig, aber für Programmieranfänger hilfreich, weil dann
// Fehler vom Browser besser/früher erkannt und mitgeteilt werden können

// Es gibt unterschiedliche Arten - 'Type' - von Daten in Javascript:
// 'Number':
var myNumber1 = 0;

// 'Number' mit Kommastellen (das Komma ist in Javascript ein Punkt!):
var myNumber1 = 0.05;

// 'String': der Wert wird mit " " oder ' ' geklammert
var myText1 = "Hallo";
var myText2 = 'Hallo';

// 'Boolean': (wahr oder falsch)
var myBoolean = true;

// Das waren die einfachen 'Types', ab hier wird es komplizierter
// 'Array': eine beliebige Liste von Werten - 'Values' mit einem Namen: mit [ ] geklammert
var myArray = [0, 'Hallo', true, 0.05, false];

// 'Object': eine beliebige Zusammenfassung von Namen - 'Attributes' - und 'Values': mit { } geklammert
var myObject = { name: 'Hugo', alter: 29, programmierer: true };

// 'Function': eine Zusammenfassung von 'Statements', erkennbar am Schlüsselwort 'function' gefolgt
// von ( und ), gefolgt von 'Statements' die mit { } geklammert sind:
var myFunction = function() {
  console.log("Hallo");
}

// Bisher waren das alles unbenutzte 'Variables' für Beispiele
// Hier ist eine 'Variable', die wir wirklich nutzen und sie hat einen sprechenden 'Name'
// "layer" weist irgendwie auf eine Ebene hin - mal sehen wieso
var layer;

// Häufiger verden 'Functions' aber einfach ohne das 'var' aufgeschrieben - 'Definition' - wobei
// der Name z.B. "init" zwischen 'function' und ( ) rutscht: function init() { ... }

// Die 'Statements' einer 'Function' werden nicht sofort beim Lesen der Datei ausgeführt!
// Die 'Function' init hat nichts zwischen ( und ) stehen - sie hat keine 'Parameters'

// Diese 'Function' wird übrigens aus der HTML Seite verwendet - 'Function Call' - und zwar in der Zeile
// &lt;body class="progsp" onload="init()"&gt;
function init() {

  // Das erste 'Statement' der 'Function' init. Der 'Global' 'Variable' "layer" wird ein Wert zugewiesen.
  // Woher der Wert kommt? In diesem Fall vom Browser-Object "document" - das ist aber was für später
  // Also "layer" ist eine Ebene in unserem SVG (siehe cheatsheet.html) mit der id "layer1"
  layer = document.getElementById('layer1');

  // Alles zwischen { und } ist nicht 'Global'. Die 'Variable' "uri" ist nur innerhalb von init bekannt
  // überall sonst meldet der Browser einen Fehler."
  // Sie bekommt ihren Wert aus dem 'Attribute' namespaceURI der 'Variable' "layer" (hat den 'Type' 'Object')
  var uri = layer.namespaceURI;

  // Innerhalb von init können wir aber auf den Wert zugreifen. console.log ist eine 'Function', die
  // ebenfalls vom Browser bereitgestellt wird, um etwas auf der Browser Konsole auszugeben.
  // Dort erscheint dann der Wert von uri.
  console.log("Innerhalb von init ist uri=", uri);

  // Hier wird eine 'Function' aufgerufen 'Function Call', die weiter unten in dieser Datei 'defined'
  // wird. Für jeden 'Parameter' der 'Function' (siehe 'Definition' unten) müssen wir einen Wert mitgeben,
  // damit die Ausführung der 'Statements' der 'Function' etwas Sinnvolles ergibt.
  // Elternelement, Grösse, Anzahl (Höhe und Breite), Abstand, Farbe und Elementart:
  // 0: Rechtecke, 1: Kreise, 2: Kleckse
  // Damit mit den erzeugten Elementen im Program etwas getan werden kann, muss der Rückgabewert 'Returnvalue'
  // der 'Function' wieder in einer Variablen gespeichert werden.

  // z.B.
  // var myElems = createPattern(layer, 40, 6, 5, '#00FFFF', 1);

  // oder ein anderer 'Function Call' kann völlig andere 'Values' verwenden
  var myElems = createPattern(layer, 20, 20, 5, '#FF00FF', 2);

  // Bei einem Array hat das erste Element die Hausnummer 'Index' 0, das zweite die 1, usw.
  // Hier verändern wir die Farbe des 5. Elements!
  myElems[4].setAttribute('fill', 'lime');

  // Zur Sicherheit schauen wir mal, was wir da erzeugt haben - sichtbar im Browser in der Konsole
  console.log(myElems[4]);

  // Jetzt noch Spezialkram. Der 'Global' 'Variable' "svg" wird das SVG Element aus der Seite zugewiesen.
  // Damit erhalten wir Zugriff auf zwei wichtige Funktionen, die damit verknüpt sind.
  svg = document.getElementById('svg');
  // Wir können einen SVG Punkt anlegen und in der Variablen pt abspeichern
  pt = svg.createSVGPoint();
  // und wir können einen uns die Bildschirm Daten in der Variablen matrix abspeichern
  matrix = svg.getScreenCTM().inverse();
  // Das brauchen wir später für Umrechnung von Mouse/Bildschirm Koordinaten mit der Funktion cursorPoint
}

// Verwenden einer nicht 'Global' - 'Local' - 'Variable' erzeugt eine Fehlermeldung in der Konsole
console.log("Fehler!", uri);

// 'Functions' sind nach den 'Variables' der grundlegenste Teil eines Javascript 'Programs'
// In ihnen werden 'Statements' für spätere!!! unter Umständen mehrfache 'Function Calls' -
// zusammengefasst und mit Variablen - 'Parameters' - zwischen ( und ) versehen, damit
// sie möglichst flexibel genutzt werden können.
function createPattern(parent, width, count, gap, color, mode) {

  // Ein leere 'Array', in dem wir die erzeugten Elemente speichern wollen zur späteren Verwendung
  var elements = [];

  // Eine 'Variable' für das neue Element
  var newElem;

  // Aus den Werten der 'Parameters' "width" und "gap" berechnen wir den Platzbedarf für die Elemente, die
  // wir erzeugen möchten und merken uns diesen für die Verwendung weiter unten in der 'Variable' "box"
  var box = width + 2 * gap;

  // Aus "box" und den Werten der 'Parameters' "gap" und "count" berechnen wir die obere linke Position
  // für die Elemente, die wir erzeugen möchten und merken uns diese in der 'Variable' "offset"
  var offset = -box * count / 2 + gap;


  // Eine weitere 'Controlstructure': 'if' 'else' führt 'Statements' in Abhängigkeit von dem Zutreffen der Bedingung
  // 'Condition' zwischen ( und ) aus. der 'if' Teil nur wenn die 'Condition' 'true' ist ansonsten den 'else' Teil, der
  // aber auch fehlen kann. Vergleiche müssen mit == gemacht werden. = würde nur den 'Value' der 'Variable' ändern.
  if (mode == 2) {

    var klecks = document.getElementById('klecks');
    var scale = width * 1.5 / Math.max(klecks.getBBox().width, klecks.getBBox().height);

  }

  // Hier ist ein Beispiel für den nächsten Teil eines Javascript 'Programs': 'Controlstructures'.
  // Das sind 'Statements', die den Ablauf des 'Programs' bestimmen. In diesem Fall ist es eine
  // Wiederholungsschleife: Die 'Statements' zwischen { und } der 'for loop' werde so oft wiederholt,
  // wie es in der Schleifendefinition bestimmt wird: Die Variable "col" wird mit 0 initialisiert (var col = 0)
  // nach jedem Durchlauf wird sie verändert (coll++) und es wird geprüft, ob die Bedingung (col < count) zutrifft.
  // Wenn das nicht mehr der Fall ist, wird die Schleife beendet und das 'Statement' nach } wird ausgeführt.
  for (var col = 0; col < count; col++) {

    // Das geht natürlich auch geschachtelt mit eine weiteren 'for loop' - diesmal wird die 'Variable' "row" verwendet
    for (var row = 0; row < count; row++) {

      // Ein weiterer 'Function Call' mit 3 'Values': der Wert von parent, der Text "rect" und einem grösseren 'Object' {...},
      // das alle 'Attribute: Value' Paare für das zu erzeugende Element enthält.
      // Weil dieses 'Statement' innerhalb von 2 Schleifen ist, wird es count*count of ausgeführt - das erzeugt viele Elemente

      // Wieder die 'if' 'Controlstructure': diesmal sogar mehrfach geschachtelt. Hier werden die jeweiligen Elemente in
      // Abhängigkeit vom Modus "mode" erzeugt.
      if (mode == 0)  {

        // Hier ereugen wir mit einer einzigen Zeile viele Rechtecke
        newElem = createElement(parent, 'rect', { x: offset + row * box, y: offset + col * box, width: width, height: width, fill: color });

      } else {

        if (mode == 1)  {

          // Warum so kompliziert? Weil wir dann mit einer einzigen geänderten Zeile Kreise malen können
          newElem = createElement(parent, 'circle', { cx: offset + row * box + width/2, cy: offset + col * box + width/2, r: width/2, fill: color });

        } else {

          // Oder wir erzeugen Kopien eines versteckten SVG Elements (siehe HTML Datei)
          //cloneElement(parent, document.getElementById('klecks'), { x: offset + row * box + width/2, y: offset + col * box + width/2, size: width, fill: color });
          newElem = cloneElement(parent, klecks, { transform: 'translate(' + (offset + row * box + width / 2) + ' ' + (offset + col * box + width / 2) + ') scale(' + scale + ' ' + scale + ')'});

          // Damit die Farbe nachträglich änderbar bleibt, ändern wir sie über die äußere Gruppe des der Kopie mit der 'Function' "setAttribute"
          newElem.setAttribute('fill', color);

        }

      }

      // Ein 'Array' hat immer die 'Function' "push" mit der etwas am Ende der Liste hinzugefügt werden kann.
      elements.push(newElem);

    }

  }

  // Alle erzeugten Elemente werden im 'Array' "elements" zur weiteren Verwendung zurückgegeben 'returned'
  return elements;
}


// Diese Function' erzeugt neue Elemente im Dokument. Sie hat als 'Parameters' das Eltern-Element (parent), die Art des Elements
// (type: 'rect', 'circle', ...) und das 'Object' mir den 'Attribute: Value' Paaren für das neue Element (attrList)
function createElement(parent, type, attrList) {

  // Über das document 'Object' (vom Browser) greifen wir auf eine Funktion des Browsers zu, die uns ein neues Element erzeugt.
  // Diese Element wird in der 'Variable' mit dem Namen "elem" gespeichert
  var elem = document.createElementNS(parent.namespaceURI, type);

  // Das neue Element "elem" wird an das Elternelement "parent" angehängt über die 'Function' "appendChild" über die jedes
  // Element eines Documents verfügt
  parent.appendChild(elem);

  // Jetzt werden über eine spezielle "for loop" für 'Objects' alle "Attribute" des 'Objects' "attrList" durchlaufen
  for (attr in attrList) {

    // Das Element "elem" besitzt eine 'Function' "setAttribute" über die wir 'Attributes' in "attr" mit 'Values' in attrList[attr]
    // zuweisen. Das Element bekommt z.B. Position "x" und "y", Grösse "Width" und "height" und Farbe "fill"
    elem.setAttribute(attr, attrList[attr]);

  }

  // Das erzeugte Element "elem" wird dem Aufrufer 'Caller' der 'Function' zur weiteren Verwendung zurückgegeben 'returned'
  return elem;
}


// Diese Function' erzeugt neue Elemente im Dokument durch kopieren "cloneNode". Sie hat als 'Parameters' das Eltern-Element
// (parent), das zu kopierende Elements und das 'Object' mir den 'Attribute: Value' Paaren für das neue Element (attrList)
function cloneElement(parent, elem, attrList) {

  // Hier wird vom Element "elem" über dessen 'Function' "cloneNode" dupliziert
  var clone = elem.cloneNode(true);

  // Das neue Element muss mit Hilfe einer neuen Gruppe an die richtige Stelle in der richtigen Grösse verschoben werden
  // Das ist nötig weil wir hier den Aufbau des Elements nicht kennen
  var place = createElement(parent, 'g', attrList);

  // Jetzt wird die Kopie des Elements in diese Gruppe bewegt und ist damit richtig positioniert
  place.appendChild(clone);

  // Damit wir die Kopie des Elements später manipulieren könne (Animation, Interaktion) müssen wir das Ganze nochmal
  // in eine Gruppe verpacken, deren 'Attributes' leer sind, damit wir sie später füllen können
  var wrap = createElement(parent, 'g', {});
  wrap.appendChild(place);

  // Das erzeugte Element "wrap" wird dem Aufrufer 'Caller' der 'Function' zur weiteren Verwendung zurückgegeben 'returned'
  return wrap;
}

// Umrechnen von Bildschirm Koordineten in SVG Koordinaten
function cursorPoint(evt) {
  pt.x = evt.clientX;
  pt.y = evt.clientY;
  return pt.matrixTransform(matrix);
}
        </code>
      </pre>
</body>
</html>
